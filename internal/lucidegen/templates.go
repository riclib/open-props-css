package lucidegen

import (
	"os"
	"strings"
	"text/template"
	"time"
)

// Template for individual icon components
const iconsTemplate = `// Code generated by lucide-templ-gen on {{.Timestamp}}. DO NOT EDIT.
// Source: https://github.com/lucide-icons/lucide
// Generator: https://github.com/riclib/open-props-css

package {{.PackageName}}

{{range .Icons}}
// {{.FuncName}} renders the {{.Name}} Lucide icon
// Category: {{.Category}}
templ {{.FuncName}}(attrs templ.Attributes) {
	<svg viewBox="{{.ViewBox}}" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" { attrs... }>
		{{.Content}}
	</svg>
}
{{end}}`

// Template for icon registry
const registryTemplate = `// Code generated by lucide-templ-gen on {{.Timestamp}}. DO NOT EDIT.

package {{.PackageName}}

// IconName represents a valid Lucide icon name
type IconName string

// Icon name constants
const (
{{range .Icons}}	{{call $.ToConstantName .Name $.Prefix}} IconName = "{{.Name}}"
{{end}})

// Icon renders any Lucide icon by name with type safety
templ Icon(name IconName, attrs templ.Attributes) {
	switch name {
{{range .Icons}}	case {{call $.ToConstantName .Name $.Prefix}}:
		@{{.FuncName}}(attrs)
{{end}}	}
}

// IconExists checks if an icon name is valid
func IconExists(name string) bool {
	switch IconName(name) {
{{range .Icons}}	case {{call $.ToConstantName .Name $.Prefix}}:
		return true
{{end}}	default:
		return false
	}
}

// AllIcons returns all available icon names
func AllIcons() []IconName {
	return []IconName{
{{range .Icons}}		{{call $.ToConstantName .Name $.Prefix}},
{{end}}	}
}

// IconCount returns the total number of available icons
func IconCount() int {
	return {{len .Icons}}
}

// IconByName returns the IconName for a string name if it exists
func IconByName(name string) (IconName, bool) {
	iconName := IconName(name)
	if IconExists(name) {
		return iconName, true
	}
	return "", false
}`

// Template for search functionality (should be a .go file, not .templ)
const searchTemplate = `// Code generated by lucide-templ-gen on {{.Timestamp}}. DO NOT EDIT.

package {{.PackageName}}

import (
	"sort"
	"strings"
)

// SearchResult represents a search result with relevance scoring
type SearchResult struct {
	IconName  IconName
	Relevance int // Higher is more relevant
	MatchType string // "exact", "tag", "category", "partial"
}

// IconSearcher provides search and filter functionality for icons
type IconSearcher struct {
	icons []SearchData
	tagIndex map[string][]IconName
	categoryIndex map[string][]IconName
}

// SearchData contains searchable metadata for an icon
type SearchData struct {
	Name       IconName
	Tags       []string
	Categories []string
	AllText    string // Pre-computed search text for efficiency
}

// NewIconSearcher creates a new search instance with precomputed indexes
func NewIconSearcher() *IconSearcher {
	search := &IconSearcher{
		icons: []SearchData{
{{range .Icons}}			{
				Name:       {{call $.ToConstantName .Name $.Prefix}},
				Tags:       []string{{"{"}}{{range .Tags}}"{{.}}", {{end}}{{"}"}},
				Categories: []string{{"{"}}{{range .LucideCategories}}"{{.}}", {{end}}{{"}"}},
				AllText:    strings.ToLower("{{.Name}} {{join .Tags " "}} {{join .LucideCategories " "}}"),
			},
{{end}}		},
		tagIndex:      make(map[string][]IconName),
		categoryIndex: make(map[string][]IconName),
	}
	
	search.buildIndexes()
	return search
}

// buildIndexes creates lookup indexes for faster searching
func (s *IconSearcher) buildIndexes() {
	for _, icon := range s.icons {
		// Build tag index
		for _, tag := range icon.Tags {
			tagKey := strings.ToLower(tag)
			s.tagIndex[tagKey] = append(s.tagIndex[tagKey], icon.Name)
		}
		
		// Build category index
		for _, category := range icon.Categories {
			categoryKey := strings.ToLower(category)
			s.categoryIndex[categoryKey] = append(s.categoryIndex[categoryKey], icon.Name)
		}
	}
}

// Search performs incremental search across icon names, tags, and categories
func (s *IconSearcher) Search(query string) []SearchResult {
	if query == "" {
		return s.getAllIcons()
	}
	
	query = strings.ToLower(strings.TrimSpace(query))
	var results []SearchResult
	seen := make(map[IconName]bool)
	
	// 1. Exact name matches (highest relevance)
	for _, icon := range s.icons {
		if strings.ToLower(string(icon.Name)) == query {
			results = append(results, SearchResult{
				IconName:  icon.Name,
				Relevance: 100,
				MatchType: "exact",
			})
			seen[icon.Name] = true
		}
	}
	
	// 2. Exact tag matches
	if icons, exists := s.tagIndex[query]; exists {
		for _, iconName := range icons {
			if !seen[iconName] {
				results = append(results, SearchResult{
					IconName:  iconName,
					Relevance: 90,
					MatchType: "tag",
				})
				seen[iconName] = true
			}
		}
	}
	
	// 3. Exact category matches
	if icons, exists := s.categoryIndex[query]; exists {
		for _, iconName := range icons {
			if !seen[iconName] {
				results = append(results, SearchResult{
					IconName:  iconName,
					Relevance: 80,
					MatchType: "category",
				})
				seen[iconName] = true
			}
		}
	}
	
	// 4. Partial matches in names, tags, and categories
	for _, icon := range s.icons {
		if !seen[icon.Name] && strings.Contains(icon.AllText, query) {
			relevance := s.calculatePartialRelevance(icon, query)
			if relevance > 0 {
				results = append(results, SearchResult{
					IconName:  icon.Name,
					Relevance: relevance,
					MatchType: "partial",
				})
			}
		}
	}
	
	// Sort by relevance (highest first)
	sort.Slice(results, func(i, j int) bool {
		return results[i].Relevance > results[j].Relevance
	})
	
	return results
}

// SearchByCategory returns all icons in a specific category
func (s *IconSearcher) SearchByCategory(category string) []IconName {
	if icons, exists := s.categoryIndex[strings.ToLower(category)]; exists {
		result := make([]IconName, len(icons))
		copy(result, icons)
		return result
	}
	return []IconName{}
}

// SearchByTag returns all icons with a specific tag
func (s *IconSearcher) SearchByTag(tag string) []IconName {
	if icons, exists := s.tagIndex[strings.ToLower(tag)]; exists {
		result := make([]IconName, len(icons))
		copy(result, icons)
		return result
	}
	return []IconName{}
}

// GetAllTags returns all available tags sorted alphabetically
func (s *IconSearcher) GetAllTags() []string {
	tags := make([]string, 0, len(s.tagIndex))
	for tag := range s.tagIndex {
		tags = append(tags, tag)
	}
	sort.Strings(tags)
	return tags
}

// GetAllCategories returns all available categories sorted alphabetically
func (s *IconSearcher) GetAllCategories() []string {
	categories := make([]string, 0, len(s.categoryIndex))
	for category := range s.categoryIndex {
		categories = append(categories, category)
	}
	sort.Strings(categories)
	return categories
}

// GetTagsForIcon returns all tags for a specific icon
func (s *IconSearcher) GetTagsForIcon(iconName IconName) []string {
	for _, icon := range s.icons {
		if icon.Name == iconName {
			result := make([]string, len(icon.Tags))
			copy(result, icon.Tags)
			return result
		}
	}
	return []string{}
}

// GetCategoriesForIcon returns all categories for a specific icon
func (s *IconSearcher) GetCategoriesForIcon(iconName IconName) []string {
	for _, icon := range s.icons {
		if icon.Name == iconName {
			result := make([]string, len(icon.Categories))
			copy(result, icon.Categories)
			return result
		}
	}
	return []string{}
}

// GetIconCount returns the total number of searchable icons
func (s *IconSearcher) GetIconCount() int {
	return len(s.icons)
}

// calculatePartialRelevance calculates relevance score for partial matches
func (s *IconSearcher) calculatePartialRelevance(icon SearchData, query string) int {
	iconName := strings.ToLower(string(icon.Name))
	
	// Name starts with query - high relevance
	if strings.HasPrefix(iconName, query) {
		return 70
	}
	
	// Name contains query - medium relevance
	if strings.Contains(iconName, query) {
		return 60
	}
	
	// Tag starts with query - medium relevance
	for _, tag := range icon.Tags {
		if strings.HasPrefix(strings.ToLower(tag), query) {
			return 50
		}
	}
	
	// Tag contains query - lower relevance
	for _, tag := range icon.Tags {
		if strings.Contains(strings.ToLower(tag), query) {
			return 40
		}
	}
	
	// Category contains query - lowest relevance
	for _, category := range icon.Categories {
		if strings.Contains(strings.ToLower(category), query) {
			return 30
		}
	}
	
	return 0
}

// getAllIcons returns all icons with default relevance
func (s *IconSearcher) getAllIcons() []SearchResult {
	results := make([]SearchResult, len(s.icons))
	for i, icon := range s.icons {
		results[i] = SearchResult{
			IconName:  icon.Name,
			Relevance: 50,
			MatchType: "all",
		}
	}
	return results
}

// SearchOptions provides configuration for search behavior
type SearchOptions struct {
	MaxResults int
	MinRelevance int
	Categories []string // Filter by specific categories
	Tags []string // Filter by specific tags
}

// SearchWithOptions performs search with additional filtering options
func (s *IconSearcher) SearchWithOptions(query string, options SearchOptions) []SearchResult {
	results := s.Search(query)
	
	// Apply category filter
	if len(options.Categories) > 0 {
		filtered := []SearchResult{}
		categorySet := make(map[string]bool)
		for _, cat := range options.Categories {
			categorySet[strings.ToLower(cat)] = true
		}
		
		for _, result := range results {
			iconCategories := s.GetCategoriesForIcon(result.IconName)
			for _, cat := range iconCategories {
				if categorySet[strings.ToLower(cat)] {
					filtered = append(filtered, result)
					break
				}
			}
		}
		results = filtered
	}
	
	// Apply tag filter
	if len(options.Tags) > 0 {
		filtered := []SearchResult{}
		tagSet := make(map[string]bool)
		for _, tag := range options.Tags {
			tagSet[strings.ToLower(tag)] = true
		}
		
		for _, result := range results {
			iconTags := s.GetTagsForIcon(result.IconName)
			for _, tag := range iconTags {
				if tagSet[strings.ToLower(tag)] {
					filtered = append(filtered, result)
					break
				}
			}
		}
		results = filtered
	}
	
	// Apply minimum relevance filter
	if options.MinRelevance > 0 {
		filtered := []SearchResult{}
		for _, result := range results {
			if result.Relevance >= options.MinRelevance {
				filtered = append(filtered, result)
			}
		}
		results = filtered
	}
	
	// Apply max results limit
	if options.MaxResults > 0 && len(results) > options.MaxResults {
		results = results[:options.MaxResults]
	}
	
	return results
}`

// Template for categorized icon access
const categoriesTemplate = `// Code generated by lucide-templ-gen on {{.Timestamp}}. DO NOT EDIT.

package {{.PackageName}}

// Category name constants
const (
{{range .Categories}}	Category{{call $.ToCategoryName .}} = "{{.}}"
{{end}})

{{range $category := .Categories}}
// {{call $.ToCategoryName $category}}Icons returns all {{$category}} category icons
func {{call $.ToCategoryName $category}}Icons() []IconName {
	return []IconName{
{{range $.Icons}}{{if eq .Category $category}}		{{call $.ToConstantName .Name $.Prefix}},
{{end}}{{end}}	}
}
{{end}}

// IconsByCategory returns icons grouped by category
func IconsByCategory() map[string][]IconName {
	return map[string][]IconName{
{{range $category := .Categories}}		Category{{call $.ToCategoryName $category}}: {{call $.ToCategoryName $category}}Icons(),
{{end}}	}
}

// GetIconCategory returns the category for a given icon name
func GetIconCategory(name IconName) string {
	switch name {
{{range .Icons}}	case {{call $.ToConstantName .Name $.Prefix}}:
		return "{{.Category}}"
{{end}}	default:
		return ""
	}
}

// AllCategories returns all available category names
func AllCategories() []string {
	return []string{
{{range .Categories}}		Category{{call $.ToCategoryName .}},
{{end}}	}
}`

// TemplateData holds data for template execution
type TemplateData struct {
	PackageName    string
	Prefix         string
	Icons          []IconData
	Categories     []string
	Timestamp      string
	ToConstantName func(string, string) string
	ToCategoryName func(string) string
	Join           func([]string, string) string
}

// generateIconsFile creates the main icons template file
func generateIconsFile(icons []IconData, config Config, outputPath string) error {
	data := TemplateData{
		PackageName: config.PackageName,
		Prefix:      config.Prefix,
		Icons:       icons,
		Timestamp:   time.Now().Format(time.RFC3339),
		Join:        joinStrings,
	}

	tmpl := template.Must(template.New("icons").Parse(iconsTemplate))

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, data)
}

// generateRegistryFile creates the icon registry file
func generateRegistryFile(icons []IconData, config Config, outputPath string) error {
	data := TemplateData{
		PackageName:    config.PackageName,
		Prefix:         config.Prefix,
		Icons:          icons,
		Timestamp:      time.Now().Format(time.RFC3339),
		ToConstantName: toConstantName,
		Join:           joinStrings,
	}

	tmpl := template.Must(template.New("registry").Parse(registryTemplate))

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, data)
}

// generateCategoriesFile creates the categories file
func generateCategoriesFile(icons []IconData, config Config, outputPath string) error {
	categories := getUniqueCategories(icons)

	data := TemplateData{
		PackageName:    config.PackageName,
		Prefix:         config.Prefix,
		Icons:          icons,
		Categories:     categories,
		Timestamp:      time.Now().Format(time.RFC3339),
		ToConstantName: toConstantName,
		ToCategoryName: toCategoryName,
		Join:           joinStrings,
	}

	tmpl := template.Must(template.New("categories").Parse(categoriesTemplate))

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, data)
}

// toCategoryName converts a category name to a function name
func toCategoryName(category string) string {
	// Convert to title case and remove special characters
	parts := strings.Split(category, "-")
	var result strings.Builder

	for _, part := range parts {
		if len(part) > 0 {
			result.WriteString(strings.ToUpper(part[:1]))
			if len(part) > 1 {
				result.WriteString(part[1:])
			}
		}
	}

	return result.String()
}

// joinStrings joins a slice of strings with a separator
func joinStrings(slice []string, sep string) string {
	return strings.Join(slice, sep)
}

// generateSearchFile creates the search functionality file
func generateSearchFile(icons []IconData, config Config, outputPath string) error {
	data := TemplateData{
		PackageName:    config.PackageName,
		Prefix:         config.Prefix,
		Icons:          icons,
		Timestamp:      time.Now().Format(time.RFC3339),
		ToConstantName: toConstantName,
		ToCategoryName: toCategoryName,
		Join:           joinStrings,
	}

	tmpl := template.Must(template.New("search").Funcs(template.FuncMap{
		"join": joinStrings,
	}).Parse(searchTemplate))

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, data)
}